# The Armv8 Application Level Memory Model.
#
# This is a machine-readable, executable and formal artefact, which aims to
# generate systematic families of litmus tests which are forbidden by the Arm
# memory model.
# If you have comments on the content of this file, please send an email to
# jade.alglave@arm.com, referring to version number:
# 9470edab1356b1d824422808bf681d59529e8b91
#
# For the executable formal Armv memory model, see:
# https://developer.arm.com/architectures/cpu-architecture/a-profile/memory-model-tool
# For a textual version of the model, see section B2.3 of the Armv8 ARM:
# https://developer.arm.com/docs/ddi0487/latest/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile
#
# Author: Will Deacon <will.deacon@arm.com>
# Author: Jade Alglave <jade.alglave@arm.com>
#
# Copyright (C) 2016-2025, Arm Ltd.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#     * Neither the name of ARM nor the names of its contributors may be
#       used to endorse or promote products derived from this software
#       without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
# IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
# TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

-arch AArch64
-nprocs 2
-size 4
# the generate file name is in format `Armv8-ext-forbidden******.litmus`,
# where `******` are 6 digit numbers.
-name Armv8-ext-forbidden
-fmt 6
# present value in hex
-hexa
# If only want to generate cycles rather than litmus tests
#-cycleonly true

-oneloc
-variant kvm

#-relax [PteOneAF DSB.SYs**] [PteOneAF DSB.SYs**]
#-relax [PteOneAF DSB.STsWW] [PteOneAF DSB.STsWW]
#-relax [PteOneVALID DSB.SYs**] [PteOneVALID DSB.SYs**]
#-relax [PteOneVALID DSB.STsWW] [PteOneVALID DSB.STsWW]
# HU-pred
#-relax [Fre PteTTHMHD] [Fre PteTTHMHA] [Coe PteTTHMHA] [Coe PteTTHMHD]
#-relax [Fri PteTTHMHD] [Fri PteTTHMHA] [Coi PteTTHMHA] [Coi PteTTHMHD]


# let haz-ob = TLBI-ob
# let TLBI-ob = TTD-read-ordered-before
# let TTD-read-ordered-before = TLBI-after; [TLBI]; po; [dsb.full]; po; [~(Imp & M)]
# let DSB-ob = [M | DC.CVAU | IC]; po; [dsb.full]; po; [~(Imp & TTD & M | Imp & Instr & R)]
# The ideas:
# `Pte** TLBI-sync.ISH*W*` generate a sequence of `WriteToPte, DSB.ISH, TLBI, DSB.ISH, MemoryEvent`.
# The first section `WriteToPte, DSB.ISH, TLBI` will be ordered by `DSB-ob` and
# the second section `TLBI, DSB.ISH, MemoryEvent` will be ordered by part of `TTD-read-ordered-before`.
# Here we change the Pte that might trigger fault, namely (1) valid = 0 or af = 0 on read and write, and (2) db = 0 on write.
# The communication edge before the `pte` write to an address, x, adds a plain memory access from the end of a thread, P1, to the beginning of
# the current thread, P0. This will create a `TLBI-after` edge, if the other thread P1 ONLY have one access to the location x.
###
# Note that we are only interested in the different location in this clause.
# A very special pattern in same location leads to a allowed test [PteZero* TLBI.ISHsWR A Amo.Cas L PodWW Coe].
###
-relax [Fre PteZeroVALID TLBI-sync.ISHdW*] [Coe PteZeroVALID TLBI-sync.ISHdW*]
-relax [Fre PteZeroAF TLBI-sync.ISHdW*] [Coe PteZeroAF TLBI-sync.ISHdW*]
-relax [Coe PteZeroDB TLBI-sync.ISHdW*]
## The following is very slow in `herd7`
#-relax [Fre PteTTHMHD TLBI-sync.ISHdW*] [Coe PteTTHMHD TLBI-sync.ISHdW*]
#-relax [Fre PteTTHMHA TLBI-sync.ISHd**] [Coe PteTTHMHA TLBI-sync.ISHd**] [Rfe PteTTHMHA TLBI-sync.ISHd**]

# Rejects ordering that is not valid for TTD-read-ordered-before due to the way we construct `TLBI-after`.
# The ISBsRR does not create a TTD-read-ordered before as expected, because it may create two memory access
# to the some location esp whose Pte value is changed. This means it may not form a cycle as we expected.
-rejectlist [DpAddrCseldR ISBsRR]

# let TTD-read-ordered-before = TLBI-after; [TLBI]; po; [dsb.full]; po; [IFB]; po; [Imp & M]
-relax [TLBI-sync.ISHs** ISB]
-relax [TLBI-sync.ISHd**]

-relax [Fri PteZeroVALID TLBI-sync.ISHs** ISB]
-relax [PteZeroVALID Rfe TLBI-sync.ISHs** ISB]
-relax [Coe PteZero* TLBI-sync.ISHs** ISB]

-relax [Fri PteZeroDB TLBI-sync.ISHs** ISB]
-relax [Fri PteOneAF TLBI-sync.ISHs** ISB]
-relax [Fri PteOneVALID TLBI-sync.ISHs** ISB]
-relax [Fri PteOneDB TLBI-sync.ISHs** ISB]
-relax [Fri PteTTHMHA TLBI-sync.ISHs** ISB]
-relax [Fri PteTTHMHD TLBI-sync.ISHs** ISB]
-relax [Coi PteZeroVALID TLBI-sync.ISHs** ISB]
-relax [Coi PteZeroDB TLBI-sync.ISHs** ISB]
-relax [Coi PteOneAF TLBI-sync.ISHs** ISB]
-relax [Coi PteOneVALID TLBI-sync.ISHs** ISB]
-relax [Coi PteOneDB TLBI-sync.ISHs** ISB]
-relax [Coi PteTTHMHA TLBI-sync.ISHs** ISB]
-relax [Coi PteTTHMHD TLBI-sync.ISHs** ISB]
-relax [Fre PteZeroVALID TLBI-sync.ISHdW*]

# Hat causes problem when two reads are to the location and the `Pte` of such location.
# Hence we rule out all `Hat` in `vmsa`
#-rejectlist [Hat]

# let TTD-obs = rf; [Imp & TTD]
# Since it is a read-from realtion to implicit ttd event, it implicitly means
# the write event before MUST be a ttd related write.
# We only toggle the field that leads to some interesting result hence AF and VALID.
#-relax [PteVALID Rfe]
# The following is NOT in order.
#-reject [Fre Pte*]
#-relax [PteAF Rfe]
# let TTD-obs = [Imp & TTD]; rf

# let ca = fr | co
# let Exp-obs =
#   [Exp & M]; rf & ext; [Exp & M]
#   | [Exp & M]; ca & ext; [Exp & M]
-safe Rfe Fre Coe

#let Exp-haz-ob = [Exp & R]; (po & same-loc); [Exp & R]; (ca & ext); [Exp & W]
-safe [PosRR Fre]

-safe Pos*W

### Data and address dependance
# what is same instance?
# let data = [Exp & R]; (basic-dep; [DATA]; iico_data+; [Exp & W]) & ~same-instance
# let dob = data
-safe DpDatadW DpDatasW

# let addr = [Exp & R]; (basic-dep; [ADDR]; iico_data+; [Exp & M | Imp & Tag & R | Imp & TTD & R | HU | TLBI | DC.CVAU | IC.IVAU]) & ~same-instance
# let dob = addr
-safe DpAddrdR DpAddrdW DpAddrsR DpAddrsW

# let ctrl = [Exp & R]; basic-dep; [BCC]; po
# let dob = ctrl; [Exp & W | HU | TLBI | DC.CVAU | IC]
# mcat2config7 aarch64.cat -let dob
-safe DpCtrldW DpCtrlsW

# let dob = addr; [Exp & M]; po; [Exp & W | HU]
-safe [DpAddrdW PodWW] [DpAddrdW PosWW] [DpAddrsW PodWW] [DpAddrsW PosWW] [DpAddrdR PodRW] [DpAddrdR PosRW] [DpAddrsR PodRW] [DpAddrsR PosRW]

# let dob = addr; [Exp & M]; lrs; [Exp & R | Imp & Tag & R]
# let lrs = [W]; ((po & same-loc) & ~(intervening(W,(po & same-loc)))); [R]
-safe [DpAddrdW Rfi] [DpAddrsW Rfi]

# let dob = data; [Exp & M]; lrs; [Exp & R | Imp & Tag & R]
# let lrs = [W]; ((po & same-loc) & ~(intervening(W,(po & same-loc)))); [R]
-safe [DpDatadW Rfi] [DpDatasW Rfi]

# let ctrl = [Exp & R]; basic-dep; [BCC]; po
# let IFB-ob = [Exp & R]; ctrl; [IFB]; po
# let IFB = ISB | EXC-ENTRY-IFB | EXC-RET-IFB
-safe [DpCtrldR ISB] [DpCtrldW ISB] [DpCtrlsR ISB] [DpCtrlsW ISB]

# let IFB-ob = [Exp & R]; pick-ctrl-dep; [IFB]; po
# let IFB = ISB | EXC-ENTRY-IFB | EXC-RET-IFB
-safe [DpCtrlCseldR ISB] [DpCtrlCseldW ISB] [DpCtrlCselsR ISB] [DpCtrlCselsW ISB]

# let IFB-ob = [Exp & R]; addr; [Exp & M]; po; [IFB]; po
-safe [DpAddrdR ISBd**] [DpAddrdR ISBs**] [DpAddrdW ISBd**] [DpAddrdW ISBs**] [DpAddrsR ISBd**] [DpAddrsR ISBs**] [DpAddrsW ISBd**] [DpAddrsW ISBs**]
# let IFB-ob = [Exp & R]; pick-addr-dep; [Exp & M]; po; [IFB]; po
-safe [DpAddrCseldR ISBd**] [DpAddrCseldR ISBs**] [DpAddrCseldW ISBd**] [DpAddrCseldW ISBs**] [DpAddrCselsR ISBd**] [DpAddrCselsR ISBs**] [DpAddrCselsW ISBd**] [DpAddrCselsW ISBs**]
#
# let pob = pick-addr-dep; [Exp & W | HU | TLBI | DC.CVAU | IC]
# mcat2config7 aarch64.cat -let pob
-safe DpAddrCseldW DpAddrCselsW

# let pob = pick-data-dep
-safe DpDataCseldW DpDataCselsW

# let pob = pick-ctrl-dep; [Exp & W | HU | TLBI | DC.CVAU | IC]
-safe DpCtrlCseldW DpCtrlCselsW

# let pob = pick-addr-dep; [Exp & M]; po; [Exp & W | HU]
-safe [DpAddrCseldR PodRW] [DpAddrCseldR PosRW] [DpAddrCseldW PodWW] [DpAddrCseldW PosWW] [DpAddrCselsR PodRW] [DpAddrCselsR PosRW] [DpAddrCselsW PodWW] [DpAddrCselsW PosWW]

### Fence
# DMB.ISH*** DMB.OSH*** in `-moreedges` in `diy7`; these two edges also satisfies `dmb.full`
###
# `DSB` is stronger than `DMB`
###

# let bob = [Exp & M | Imp & Tag & R]; po; [dmb.full]; po; [Exp & M | Imp & Tag & R | MMU & FAULT]
-safe DMB.SYd** DMB.SYs**
-safe DSB.SYd** DSB.SYs**

# let bob = [Exp & (R \ NoRet) | Imp & Tag & R]; po; [dmb.ld]; po; [Exp & M | Imp & Tag & R | MMU & FAULT]
-safe DMB.LDdR* DMB.LDsR*
-safe DSB.LDdR* DSB.LDsR*

# let bob = [Exp & W]; po; [dmb.st]; po; [Exp & W | MMU & FAULT]
-safe DMB.STdWW DMB.STsWW
-safe DSB.STdWW DSB.STsWW

### Acquire-Release load and store
# let bob = [L]; po; [A]
-safe [L PodWR A] [L PosWR A]

### Atomic operation
# Amo.Swp
# Amo.Cas
# Amo.LdAdd Amo.LdClr Amo.LdEor Amo.LdSet Amo.LdSmax Amo.LdSmin Amo.LdUmax Amo.LdUmin
# Amo.StAdd Amo.StClr Amo.StEor Amo.StSet
# There is a known problem for the third and forth rows, due to commutative of those
# edges.
###
# `LxSx` and its variants take more time for `herd7` to simulate due to loop.
# It recommends pass `-unroll 0` to `herd7` for better performance.
###

# let bob = [A | Q]; po; [Exp & M | Imp & Tag & R | MMU & FAULT]
-safe [A PodR*] [A PosR*] [Q PodR*] [Q PosR*]
# An acquire atomic operation followed by a memory access also matches above
-safe [A Amo.Swp PodW*] [A Amo.Swp PosW*]
-safe [A Amo.Cas PodW*] [A Amo.Cas PosW*]
-safe [Q Amo.Swp PodW*] [Q Amo.Swp PosW*]
-safe [Q Amo.Cas PodW*] [Q Amo.Cas PosW*]

# let bob = [Exp & M | Imp & Tag & R]; po; [L]
-safe [Pod*W L] [Pos*W L]
# A memory access followed by a release atomic operation also matches above.
-safe [Pod*R Amo.Swp L] [Pos*R Amo.Swp L]
-safe [Pod*R Amo.Cas L] [Pos*R Amo.Cas L]

# let aob = [Exp & M]; rmw; [Exp & M]
-safe LxSx Amo.Swp Amo.Cas

# le aob = [Exp & M]; rmw; lrs; [A | Q]
# let lrs = [W]; ((po & same-loc) & ~(intervening(W,(po & same-loc)))); [R]
-safe [LxSx Rfi A] [Amo.Swp Rfi A] [Amo.Cas Rfi A]
-safe [LxSx Rfi Q] [Amo.Swp Rfi Q] [Amo.Cas Rfi Q]

#let bob = [range([A];amo;[L])]; po; [Exp & M | Imp & Tag & R | MMU & FAULT]
-safe [A Amo.Swp L PodW*] [A Amo.Swp L PosW*]
-safe [A Amo.Cas L PodW*] [A Amo.Cas L PosW*]
#
# let bob = [Exp & M | Imp & Tag & R]; po; [L] for `Pos*** A Amo.* L` Note that `A` is irrelevant
# then let [range([A];amo;[L])]; po; [Exp & M | Imp & Tag & R | MMU & FAULT] for `A Amo.* L Po***`
# This particular edges cannot be auto generated from other safe edges.
-safe [Pod*R A Amo.Swp L PodW*] [Pod*R A Amo.Swp L PosW*] [Pos*R A Amo.Swp L PodW*] [Pos*R A Amo.Swp L PosW*]
-safe [Pod*R A Amo.Cas L PodW*] [Pod*R A Amo.Cas L PosW*] [Pos*R A Amo.Cas L PodW*] [Pos*R A Amo.Cas L PosW*]

### Hat
# `Hat` is an a read-read communication edge in `diy`, namely
# the end of a thread and the beginning of antoher thread are both read events
# and they will read the same value.
###
#-safe [Hat Fre]
#-safe [Hat DpAddrdR] [Hat DpAddrdW]
#-safe [Hat DpDatadW]
#-safe [Hat DpCtrldW]
#-safe [Hat DMB.SYdR*]
#-safe [Hat DSB.SYdR*]
#-safe [Hat DMB.LDdR*]
#-safe [Hat DSB.LDdR*]
#-safe [Hat A PodR*] [Hat Q PodR*]
#-safe [Hat Amo.Swp] [Hat Amo.Cas]
