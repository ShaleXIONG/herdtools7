# The Armv8 Application Level Memory Model.
#
# This is a machine-readable, executable and formal artefact, which aims to
# generate systematic families of litmus tests which are forbidden by the Arm
# memory model.
# If you have comments on the content of this file, please send an email to
# jade.alglave@arm.com, referring to version number:
# 9470edab1356b1d824422808bf681d59529e8b91
#
# For the executable formal Armv memory model, see:
# https://developer.arm.com/architectures/cpu-architecture/a-profile/memory-model-tool
# For a textual version of the model, see section B2.3 of the Armv8 ARM:
# https://developer.arm.com/docs/ddi0487/latest/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile
#
# Author: Will Deacon <will.deacon@arm.com>
# Author: Jade Alglave <jade.alglave@arm.com>
#
# Copyright (C) 2016-2020, Arm Ltd.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#     * Neither the name of ARM nor the names of its contributors may be
#       used to endorse or promote products derived from this software
#       without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
# IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
# TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

-arch AArch64
-nprocs 2
-size 5
# the generate file name is in format `Armv8-ext-forbidden******.litmus`,
# where `******` are 6 digit numbers.
-name Armv8-ext-forbidden
-fmt 6
# present value in hex
-hexa
# If only want to generate cycles rather than litmus tests
#-cycleonly true

# If any relax input present, the cycles or litmus tests will contain at least one relaxation
#-relax {RELAX_LIST}

# let ca = fr | co
# let Exp-obs =
#   [Exp & M]; rf & ext; [Exp & M]
#   | [Exp & M]; ca & ext; [Exp & M]
# mcat2config7 aarch64.cat -let Exp-obs TODO missing Co.
-safe Rfe Fre Coe

#let Exp-haz-ob = [Exp & R]; (po & same-loc); [Exp & R]; (ca & ext); [Exp & W]
# mcat2config7 aarch64.cat -let Exp-haz-ob TODO nothing return
-safe [PosRR Coe] [PosRR Fre]
# TODO QUESTION other edges with same locations ?

### Data and address dependance
# what is same instance?
# let data = [Exp & R]; (basic-dep; [DATA]; iico_data+; [Exp & W]) & ~same-instance
# let dob = data
# mcat2config7 aarch64.cat -let dob
-safe DpData**

# let addr = [Exp & R]; (basic-dep; [ADDR]; iico_data+; [Exp & M | Imp & Tag & R | Imp & TTD & R | HU | TLBI | DC.CVAU | IC.IVAU]) & ~same-instance
# let dob = addr
# mcat2config7 aarch64.cat -let dob
-safe DpAddr**

# let ctrl = [Exp & R]; basic-dep; [BCC]; po
# let dob = ctrl; [Exp & W | HU | TLBI | DC.CVAU | IC]
# mcat2config7 aarch64.cat -let dob
-safe DpCtrl*W

# let dob = addr; [Exp & M]; po; [Exp & W | HU]
# mcat2config7 aarch64.cat -let dob
-safe [DpAddr** Po**W]

# let dob = addr; [Exp & M]; lrs; [Exp & R | Imp & Tag & R]
# let lrs = [W]; ((po & same-loc) & ~(intervening(W,(po & same-loc)))); [R]
# mcat2config7 aarch64.cat -let dob
-safe [DpAddr*W Rfi]

# let dob = data; [Exp & M]; lrs; [Exp & R | Imp & Tag & R]
# let lrs = [W]; ((po & same-loc) & ~(intervening(W,(po & same-loc)))); [R]
# mcat2config7 aarch64.cat -let dob
-safe [DpData*W Rfi]

# let ctrl = [Exp & R]; basic-dep; [BCC]; po
# let IFB-ob = [Exp & R]; ctrl; [IFB]; po
# let IFB = ISB | EXC-ENTRY-IFB | EXC-RET-IFB
#-safe DpCtrlIsbdR DpCtrlIsbsR
# mcat2config7 aarch64.cat -let IFB-ob
-safe [DpCtrl** ISB]

# let IFB-ob = [Exp & R]; pick-ctrl-dep; [IFB]; po
# let IFB = ISB | EXC-ENTRY-IFB | EXC-RET-IFB
# mcat2config7 aarch64.cat -let IFB-ob
-safe [DpCtrlCsel** ISB]

# let IFB-ob = [Exp & R]; addr; [Exp & M]; po; [IFB]; po
# mcat2config7 aarch64.cat -let IFB-ob TODO incorreect [DpAddrs*,ISB] [DpAddrd*,ISB], which does not work because it put ISB in between the two memory access.
-safe [DpAddr** ISB***]

# let IFB-ob = [Exp & R]; pick-addr-dep; [Exp & M]; po; [IFB]; po
# mcat2config7 aarch64.cat -let IFB-ob TODO incorreect [DpAddrCsels*,ISB] [DpAddrCseld*,ISB], which does not work because it put ISB in between the two memory access.
-safe [DpAddrCsel** ISB***]
#
# let pob = pick-addr-dep; [Exp & W | HU | TLBI | DC.CVAU | IC]
# mcat2config7 aarch64.cat -let pob
-safe DpAddrCsel*W

# let pob = pick-data-dep
# mcat2config7 aarch64.cat -let pob
-safe DpDataCsel**

# let pob = pick-ctrl-dep; [Exp & W | HU | TLBI | DC.CVAU | IC]
# mcat2config7 aarch64.cat -let pob
-safe DpCtrlCsel*W

# let pob = pick-addr-dep; [Exp & M]; po; [Exp & W | HU]
-safe [DpAddrCsel** Po**W]

### Fence
# let bob = [Exp & M | Imp & Tag & R]; po; [dmb.full]; po; [Exp & M | Imp & Tag & R | MMU & FAULT]
-safe DMB.SY***
#Note DMB.ISH*** DMB.OSH*** in moreedges

# let bob = [Exp & (R \ NoRet) | Imp & Tag & R]; po; [dmb.ld]; po; [Exp & M | Imp & Tag & R | MMU & FAULT]
-safe DMB.LD*R*

# let bob = [Exp & W]; po; [dmb.st]; po; [Exp & W | MMU & FAULT]
-safe DMB.ST*WW

### Acquire-Release load and store
# let bob = [L]; po; [A]
-safe [L Po*WR A]

# let bob = [A | Q]; po; [Exp & M | Imp & Tag & R | MMU & FAULT]
-safe [A Po*R*] [Q Po*R*]

# let bob = [Exp & M | Imp & Tag & R]; po; [L]
-safe [Po**W L]

### Read modify write
## LxSx and its variants take more time for `herd7` to simulate due to loop.
## It recommends pass `-unroll 0` to `herd7` for better performance.

# SWP and CAS
# let aob = [Exp & M]; rmw; [Exp & M]
-safe LxSx Amo.Swp Amo.Cas Amo.LdAdd Amo.StAdd
#-safe LxSx Amo.*

# le aob = [Exp & M]; rmw; lrs; [A | Q]
# let lrs = [W]; ((po & same-loc) & ~(intervening(W,(po & same-loc)))); [R]
-safe [LxSx Rfi A] [Amo.Swp Rfi A] [Amo.Cas Rfi A] [Amo.LdAdd Rfi A] [Amo.StAdd Rfi A]
-safe [LxSx Rfi Q] [Amo.Swp Rfi Q] [Amo.Cas Rfi Q] [Amo.LdAdd Rfi Q] [Amo.StAdd Rfi Q]
#-safe [LxSx Rfi A] [LxSx Rfi Q] [Amo.*, Rfi A] [Amo.*, Rfi Q]

#let bob = [range([A];amo;[L])]; po; [Exp & M | Imp & Tag & R | MMU & FAULT]
-safe [A Amo.Swp L Po***] [A Amo.Cas L Po***] [A Amo.LdAdd L Po***] [A Amo.StAdd L Po***]
#-safe [A Amo.* L Po***]

##TODO why the follow?? it will be the subset to above but do we need them ?
#-safe [A LxSx] [LxSx L] [A LxSx L]
#-safe [A Amo.*] [Amo.* L] [A Amo.* L]
#-safe [A LxSx Rfi A] [A LxSx Rfi Q] [LxSx L Rfi A] [LxSx L Rfi Q] [A LxSx L Rfi A] [A LxSx L Rfi Q]
#-safe [A Amo.* Rfi A] [A Amo.* Rfi Q] [Amo.* L Rfi A] [Amo.* L Rfi Q] [A Amo.* L Rfi A] [A Amo.* L Rfi Q]

## TODO Why bollow
#-safe [Po*** A Amo.* L]
#-safe [Po*** A Amo.* L Po***]

#### Hat
#-safe [Hat Fre]
#-safe [Hat Amo.*]
#-safe [Hat DpAddr**] [Hat DpData**] [Hat DpCtrl**]
#-safe [Hat DMB.SY***] [Hat DMB.LD***]
#-safe [Hat A PodR*] [Hat Q PodR*]
